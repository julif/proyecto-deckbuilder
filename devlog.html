<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color: #155799; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
    <header class="page-header" role="banner">
      <h1 class="project-name"> Proyecto Roguelike Deckbuilder </h1>
      <h2 class="project-tagline">Un juego web inspirado en "slay the spire".</h2>
      
       <a href="https://github.com/pages-themes/cayman" class="btn">demo v 1.0</a>
       <a href="https://github.com/pages-themes/cayman/zipball/master" class="btn">Download .zip v1.0</a>
      
         <!--  <a href="https://github.com/pages-themes/cayman/zipball/master" class="btn">Download .zip</a>
        <a href="https://github.com/pages-themes/cayman/tarball/master" class="btn">Download .tar.gz</a> -->
      
    </header>
<style>
  .nav {
    display: -ms-flexbox;
    display: flex;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    padding-left: 0;
    margin-bottom: 0;
    list-style: none;
    
     max-width: 900px; 
    margin: auto;
    padding-top: 10px;
    padding-bottom: 10px;
    padding-left: 10px;

}
.nav-link {
  
  color: #ffffff;
  

    text-decoration: none;
}
.nav-link {    
  
  font-size: large;
    font-weight: 600;

    display: block;
    padding: .5rem 1rem;
}
h3{ color: #155799;}
</style>
<div style="background-color:  #112b46;">
    <ul class="nav">
      <li class="nav-item">
        <a class="nav-link" href="index.html"  > Proyect </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="devlog.html"  style=" background-color: #155799; " > Devblog </a>
      </li>
      <!-- <li class="nav-item">
        <a class="nav-link" href="#">Link</a>
      </li>
      <li class="nav-item">
        <a class="nav-link disabled" href="#">Disabled</a>
      </li> -->
    </ul>
  </div>

    <main id="content" class="main-content" role="main">
      <h2 style="    border-bottom: solid 1px #eff0f1;"> v 0.2 - drangandrop </h2>
      <p> decidi que en lugar de hacer una barra de vida y bajarla con el boton el siguiente paso va ser hacer las cartas draggabeables y que al  dropearse en el slime llamen a la funcion atacar</p>
      <p>  para hacer que mis cartas sean draggables voy a usar <a href="https://github.com/gardiner/draganddrop" >draganddrop.js </a>, es un plugin  para Jquery que funciona incluso en dispositivos mobiles.</p>
      <p> por eso antes de nada voy llamar a jquery y luego voy a crear una carpeta para plugins y llamar desde ahi a dragandrop. </p>
      <pre><code>
        &lt!-- javascript -->
        &ltscript src="https://code.jquery.com/jquery-1.12.4.min.js"> &lt/script>
        &ltscript src='plugins/draganddrop.js' type='text/javascript'> &lt/script>
      </pre></code>
      <p> ya que estoy voy a crear un archivo style.css para darle estilo a las cartas y a la dropzone...quizas despues lo cambie a draganddrop.css o algo asi </p>
      <p> dentro de la seccion battle_stage voy a agregar una dropzone, para que se activen  las cartas</p>
      <pre><code>
        &ltdiv class="drop">&ltp>Drop here&lt/p>&lt/div>
      </pre></code>
      <p> transformo la lista desordenada en cartas.</p>
      <pre><code>
      // mostrar mazo de el jugador ------------------
      mazo_jugador.forEach( function(item, index) {
      document.getElementById("mazo_jugador_div").innerHTML += " &ltcarta id='"+ item.id +"' class='dragdrop' > "+ item.name +"  &lt/carta>";
      })
    </pre></code>
    <p> y por ultimo llamo a esta funcion( importante!! hay que llamar a la funcion despues de el codigo anterior donde se muestra la lista como cartas ) que convierte las cartas en objetos draganddrop.</p>
    <pre><code>
      $(function() {
          $('.dragdrop').draggable({
              revert: true,
              placeholder: true,
              droptarget: '.drop',
              drop: function(evt, droptarget) {
                  var currentID = evt.target.id;/*- returns  the id. */
                  $(this).appendTo(droptarget).draggable('destroy');
                  console.log(currentID);//ejecuta el codigo
                  $('.drop').find('.dragdrop').remove(); // borra los elementos una vez dentro de el drop
              }
          });
      });
  </pre></code>
        <p> bien. Ahora las cartas son draggables y dropeables, aunque por el momento dropear las cartas solo te muestra su id en la consola, la idea ahora es hacer que todas las cartas al dropear llamen a la funcion atacar().</p>
      <h2 style="    border-bottom: solid 1px #eff0f1;"> v 0.1.4 - "Slimey Boy" </h2>
      <p> ahora empieza la parte dificil. no estoy seguro de como diseñar los encuentros con enemigos o como manejar la seleccion de personajes a atacar en el caso de que el numero sea fluctuante y a su vez como manejar sus respectivos puntos de vida. Asi que lo voy a tomar con calma y lo voy a programar poco a poco </p>
      <p> empezemos simple, vamos a crear un enemigo. </p>
      <img src="https://opengameart.org/sites/default/files/slime_idle_0.gif" alt="slime" height="150" width="auto">
      <p> este pequeño slime va a servir de placeholder por el momento. </p>
      <pre><code>
        &ltenemy>&ltimg src="https://opengameart.org/sites/default/files/slime_idle_0.gif" alt="slime" height="150" width="auto"> &lt/enemy>
      </pre></code>
      <p> bien, ahora necesitamos una manera para dañar al adorable bastardo, asi que voy a incluir un boton que daña al slime. </p>
      <pre><code>
        &ltbutton onclick="atacar()" > atacar al slime  &lt/button>
        
        javascript------
        
        function atacar() {
            alert( " 10 de daño al slime ");
        }
        </pre></code>
        <p> porsupuesto esto no signfica nada, es solo un alerte que dice que daño al slime, pero nada esta pasando realmente. el slime esta bien y las cartas no influyenen lo absoluto. Pero es un inicio, ahora puedo agregarle una barra de vida al slime y quitarle realmente 10 puntos de vida cada vez que presiono el boton.</p>
      <h2 style="    border-bottom: solid 1px #eff0f1;"> v 0.1.3 - seccion "battle_stage" </h2>
      <p> por el momento tengo una lista de cartas ordenadas y otra desordenada, claro que sto es solo por el prototipo, en realidad no deberian verse juntas. Asi que voy a cambiar eso.</p>
      <p> voy a crear un tercera seccion a la que voy a llamar escenario de pelea o battle_stage, en esta seccion se va a mostrar el mazo de el jugador mientras que en la seccion de personaje va a quedar la lista incial</p>
      <h2 style="    border-bottom: solid 1px #eff0f1;"> v 0.1.2 - mazo editable </h2>
      <p> cada personaje tiene su mazo, eso es un avanze. Pero esos mazos son los iniciales. son una lista predeterminada, lo que tengo que hacer ahora es clonar los mazos iniciales para que puedean ser editables durante la partida.</p>
      <pre><code>
        var mazo_jugador = mazo_inicial.slice();
      </pre></code>
      <p> este codigo crea un clon de el mazo incial dentro de la variable "mazo_jugador", y se puede mostrar de la misma manera que el mazo inicial, solo hay que crear un div con la id mazo_jugador_div, y recordar limpiar el div cuando se vuvlve a la selecciond de personajes</p>
    
      <pre><code>
        // mostrar mazo de el jugador ------------------
        mazo_jugador.forEach( function(element, index) {
          document.getElementById("mazo_jugador_div").innerHTML += "id: "+ element.id +" name: "+ element.name +" &lt/br>"; 
        });
      </pre></code>
      <p> bien, ahora tengo 2 copias de el mismo catalogo de cartas. lo importante es que son independientes entre si, por lo cual puedo crear una funcion que mezlce el mazo jugador sin afectar el inicial.</p>
      <pre><code>
      mazo_jugador.sort(function() {return Math.random() - 0.5});
      </pre></code>
      <p> Supongo que en algun momento puedo necesitar una tercera copia que se cree cada vez que quiero revisar el mazo jugador en el medio de un match...pero eso lo vere despues. </p>
      <h2 style="    border-bottom: solid 1px #eff0f1;"> v 0.1.1 - Seleccion de personajes </h2>
      <p> lo que quiero hacer ahora es crear una pantalla de seleccion de personajes, dependiendo cual personaje se elija  se va a mostrar un mazo inicial diferente</p>
      <p> ahora supongo que tengo varias opciones para pasar de pantalla, puedo usar un Eventlistener  para cambiar entre distintos divs, puedo usar ajax, o pasar variables por la url.</p>
      <p> primero voy a intentar la opcion de Eventlistener, y si llego a tener problemas puedo ramificar el proyecto desde este punto.</p>
      <h3> v 0.1.1a "Eventlisteners" </h3>
      <p> lo primero que voy a hacer es dividir el programa en 2 secciones, la seccion "seleccion_de_personajes" y la seccion "personaje_seleccionado", una vez creadas estas 2 secciones voy a darle un display:none a "personaje_seleccionado", la idea es que si todo sale bien las secciones van a cambiar entre display none y display inherit</p>
      <p> ahora voy a crear la variable "personajeID" esta variable es importante porque va a determinar que personaje esta seleccionado y eso es lo que se va a mostrar en la siguiente seccion. pero para que el codigo sepa que personaje esta selccionado necesitamos agregar Eventlisteners. </p>
      <pre><code>
      //seleccionar un personaje --------------------------------------------------------------------------------------
      var personajeID;
      document.getElementById("char_1").addEventListener("click", function(){ select_personaje("char_1"); });
      document.getElementById("char_2").addEventListener("click", function(){ select_personaje("char_2"); });
      document.getElementById("char_3").addEventListener("click", function(){ select_personaje("char_3"); });
      </pre></code>
      <p> cada uno de estos Eventlisteners "escucha" si se clickeo el div con el id correspondiente y de ser asi llaman a la funcion  select_personaje() usando de atributo el id recibido... estoy seguro de que debe haber una manera mas eficiente de usar este codigo. </p>
      <p> despues de investigar un poco en internet, encontre una soluccion con javascript moderno. en lugar de tener un Eventlistener por cada id que quiero buscar les doy a todos los divs que llaman a la funcion la clase "selectable_character", y si detecto que algun elemento con esas clase es clikeado llamo a la funcion select_personaje() con el id de ese elemento. </p>
      <pre><code>
      //seleccionar un personaje --------------------------------------------------------------------------------------
      var personajeID;
      const divs = document.querySelectorAll('.selectable_character');
      divs.forEach(el => el.addEventListener('click', event => {
        personajeID = el.id;
        select_personaje();
      }));
      </pre></code>
      <p> lo bueno de este codigo es que a diferencia de el anterior este no necesita mantenimiento cuando agrege nuevos personajes.</p>
      <h3> la funcion "select_personaje()" </h3>
      <p> bien, ya tengo el id de el div seleccionado, ahora tengo que ver que hago con el</p>
      <p> antes que nada hay que cambiar de secciones, asi que se le da un display none a "seleccion_de_personajes" y display inherit a "personaje_seleccionado". eventualmente si quiero cambiarlo a un fade, voy a tener que hacerlo aca.</p>
      <p> inicialmente habia usado unos if para elegir que mostrar dependiendo el id seleccionado </p>
      <pre><code>
      if (personajeID=="char_1") { document.getElementById("char").innerHTML= personajeID+" personaje 1: Bunny";}
      if (personajeID=="char_2") { document.getElementById("char").innerHTML= personajeID+" personaje 2: Nero";}
      if (personajeID=="char_3") { document.getElementById("char").innerHTML= personajeID+" personaje 3: Shacta" ;} 
      </pre></code>
      <p> aun no estoy convencido de el todo, pero en el nombre de el desarrollo web apropiado lo cambie por un switch</p>
      <pre><code>
      var char_div=  document.getElementById("char");
      switch (personajeID) { 
        case "char_1":
          char_div.innerHTML= "Personaje 1: Bunny";
        break
        case "char_2":
          char_div.innerHTML= "Personaje 2: Nero";
        break
        case "char_3":
          char_div.innerHTML= "Personaje 3: Shacta";
        break
        default:
          char_div.innerHTML= " Error ";
        }
      </pre></code>
      <p> por el momento parece mas codigo para hacer lo mismo, pero confio en que es simplemente mi falta de constumbre en usar switch.</p>
      <p> ahora, los nombres de los personajes se ven perfectos y todo funciona bien...pero el mazo sigue siendo el mismo. vamos a cambiar eso.</p>
      <p> la mejor manera que se me ocurre es incluir el mazo de cada personaje dentro de el switch</p>
      <pre><code>
      var char_div=  document.getElementById("char");
      switch (personajeID) {
        case "char_1":
          char_div.innerHTML= "Personaje 1: Bunny";
          var mazo_inicial = [
            { name: 'carta 1', id: 1 },
            { name: 'carta 2', id: 2 },
            { name: 'carta 3', id: 3 },
            { name: 'carta 4', id: 4 },
            { name: 'carta 5', id: 5 },
            { name: 'carta 6', id: 6 },
            { name: 'carta 7', id: 7 },
            { name: 'carta 8', id: 8 },
            { name: 'carta 9', id: 9 },
            { name: 'carta 10', id: 10 }
          ];
         break
         case "char_2":
           char_div.innerHTML= "Personaje 2: Nero";
           var mazo_inicial = [
             { name: 'carta 11', id: 11 },
             { name: 'carta 12', id: 12 },
             { name: 'carta 13', id: 13 },
             { name: 'carta 14', id: 14 },
             { name: 'carta 15', id: 15 },
             { name: 'carta 16', id: 16 },
             { name: 'carta 17', id: 17 },
             { name: 'carta 18', id: 18 },
             { name: 'carta 19', id: 19 },
             { name: 'carta 20', id: 20 }
           ];
         break
         case "char_3":
           char_div.innerHTML= "Personaje 3: Shacta";
           var mazo_inicial = [
             { name: 'carta 21', id: 21 },
             { name: 'carta 22', id: 22 },
             { name: 'carta 23', id: 23 },
             { name: 'carta 24', id: 24 },
             { name: 'carta 25', id: 25 },
             { name: 'carta 26', id: 26 },
             { name: 'carta 27', id: 27 },
             { name: 'carta 28', id: 28 },
             { name: 'carta 29', id: 29 },
             { name: 'carta 30', id: 30 }
           ];
         break
         default:
           char_div.innerHTML= " Error ";
      }
      </pre></code>
      <p>el problema es que ahora el codigo no funciona porque las funciones que buscan al mazo inicial no encuentran nada, esto es soluccionable moviendo toda esa parte de el codigo dentro de la funcion select_personaje(), sin mencionar que me parece mas ordenado.</p>
      <p> lo unico que me falta agregar es un boton para volver a la seccion de eleccion de personajes, pero sin olvidar limpiar el innerHTML de mazo_inicial_div para que no siga sumando mazos</p>
      <pre><code>
        ------------  html -------------

        &lt button onclick="back_personajes()" > volver a seleccion de personajes &lt/button>
        
        ----------javascript------------
        
        function back_personajes() {
            document.getElementById("mazo_inicial_div").innerHTML=" ";
            document.getElementById("personaje_seleccionado").style.display="none";
            document.getElementById("seleccion_de_personajes").style.display="inherit";
        }
      
      </pre></code>
      <h2 style="    border-bottom: solid 1px #eff0f1;"> v 0.1 </h2>
      <h3> creando el mazo </h3>
      <p> lo primero que tengo que hacer es crear un mazo inicial, eventualmente van a ser varios mazos iniciales depende de que personae se elija. </p>
      <p> en esta caso el mazo es un array de obetos, descubri que esta es la mejor manera de mostrar el mazo por que me permite utilizar las funcionalidades de los array.</p>
      <pre><code>
       var mazo_inicial = [
       { name: 'carta 1', id: 1 },
       { name: 'carta 2', id: 2 },
       { name: 'carta 3', id: 3 },
       { name: 'carta 4', id: 4 },
       { name: 'carta 5', id: 5 },
       { name: 'carta 6', id: 6 },
       { name: 'carta 7', id: 7 },
       { name: 'carta 8', id: 8 },
       { name: 'carta 9', id: 9 },
       { name: 'carta 10', id: 10 }
       ];
      </code></pre>
      <h3> mostrando el mazo </h3>
      <p> para mostrar el mazo solo tengo que crear un div con el id: mazo_inicial_div y usar el siguiente codigo: </p>
      <pre><code>
        // mostrar mazo jugador ------------------
        mazo_inicial.forEach( function(element, index) {
          document.getElementById("mazo_inicial_div").innerHTML += "id: "+ element.id +" name: "+ element.name +" </br>"; 
        });
      </code></pre>
      <p> esto muestra una linea con el id y el nombre por cada objeto dentro del array mazo_inicial </p>
      <p> una vez que se muestra el mazo se puede elegir como mostrarlo, ya sea por nombre, por id o por cualquier atributo que se le agrege, por el momento creo que lo mejor es mostrarlo por orden alfabetico </p>
      <h3> ordenar el array por id </h3>
      <pre><code>
        // ordenar el array ------------------
        mazo_inicial=  mazo_inicial.sort(function(a, b) {
          return a.id-b.id; /* ordenar por id */
        });
      </pre></code>
      <h3> ordenar el array por nombre </h3>
      <pre><code>
        // ordenar el array ------------------
        mazo_inicial=  mazo_inicial.sort(function(a, b) {
          return (a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0); /* ordenar por nombre */
        });
      </pre></code>

      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/pages-themes/cayman">cayman</a> is maintained by <a href="https://github.com/pages-themes">pages-themes</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com/">GitHub Pages</a>.</span>
      </footer>
    </main>
  

</body></html>