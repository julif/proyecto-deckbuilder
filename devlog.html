<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color: #155799; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
    <header class="page-header" role="banner">
      <h1 class="project-name"> Proyecto Roguelike Deckbuilder </h1>
      <h2 class="project-tagline">Un juego web inspirado en "slay the spire".</h2>
      
       <a href="https://github.com/pages-themes/cayman" class="btn">demo v 1.0</a>
       <a href="https://github.com/pages-themes/cayman/zipball/master" class="btn">Download .zip v1.0</a>
      
         <!--  <a href="https://github.com/pages-themes/cayman/zipball/master" class="btn">Download .zip</a>
        <a href="https://github.com/pages-themes/cayman/tarball/master" class="btn">Download .tar.gz</a> -->
      
    </header>
<style>
  .nav {
    display: -ms-flexbox;
    display: flex;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    padding-left: 0;
    margin-bottom: 0;
    list-style: none;
    
     max-width: 900px; 
    margin: auto;
    padding-top: 10px;
    padding-bottom: 10px;
    padding-left: 10px;

}
.nav-link {
  
  color: #ffffff;
  

    text-decoration: none;
}
.nav-link {    
  
  font-size: large;
    font-weight: 600;

    display: block;
    padding: .5rem 1rem;
}
h3{ color: #155799;}
</style>
<div style="background-color:  #112b46;">
    <ul class="nav">
      <li class="nav-item">
        <a class="nav-link" href="index.html"  > Proyect </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="devlog.html"  style=" background-color: #155799; " > Devblog </a>
      </li>
      <!-- <li class="nav-item">
        <a class="nav-link" href="#">Link</a>
      </li>
      <li class="nav-item">
        <a class="nav-link disabled" href="#">Disabled</a>
      </li> -->
    </ul>
  </div>

    <main id="content" class="main-content" role="main">
      <div style="background-color: #112b46;padding-left: 30px;padding-right: 30px;padding-bottom: 10px;padding-top: 1px;color:#5b7794;">
        <h3 style="border-bottom: solid 2px #61a3e4; color: #3f97ec!important;padding-bottom: 5px;"> cosas para hacer:</h3>
        <ul>
          <li> mejorar IA de los enemigos </li>
          <li> mapa de enemigos </li>
          <li> crear una manera para hacerle zoom a la carta</li>
          <li> boton para ver mazo </li>
          <li> barra de experiencia para desbloquear cartas disponibles</li>
        </ul>
      </div>
            
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.21 -  rework sistema de mazos </h2>
      <p style=" color: #a0aec1bf;"> 13/4/2020</p>
      <p> hasta ahora cada vez que elegia un personaje un if me daba un array diferente por cada uno, pero la idea siempre fue que todas las cartas de elijan de un conjunto de todas las cartas disponibles.
      </p>
      <p>si hiciera un solo array con todas las cartas que tengo actualmente se veria algo asi: </p>
      <pre><code>
        var todas_las_cartas = [
        { name: 'carta 1', id: 1, card_value: 10, target_type:'dragdrop2', },
        { name: 'carta 2', id: 2, card_value: 10 , target_type:'dragdrop2'},
        { name: 'carta 3', id: 3, card_value: 10, target_type:'dragdrop'},
        { name: 'carta 4', id: 4, card_value: 10 , target_type:'dragdrop'},
        { name: 'carta 5', id: 5, card_value: 10, target_type:'dragdrop' },
        { name: 'carta 6', id: 6, card_value: 10, target_type:'dragdrop' },
        { name: 'carta 7', id: 7, card_value: 10, target_type:'dragdrop' },
        { name: 'carta 8', id: 8, card_value: 10, target_type:'dragdrop' },
        { name: 'carta 9', id: 9, card_value: 10, target_type:'dragdrop' },
        { name: 'carta 10', id: 10, card_value: 50, target_type:'dragdrop' },
        { name: 'carta 11', id: 11, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 12', id: 12, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 13', id: 13, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 14', id: 14, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 15', id: 15, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 16', id: 16, card_value: 10 ,target_type:'dragdrop' },
        { name: 'carta 17', id: 17, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 18', id: 18, card_value: 10 ,target_type:'dragdrop' },
        { name: 'carta 19', id: 19, card_value: 10 ,target_type:'dragdrop' },
        { name: 'carta 20', id: 20, card_value: 50  ,target_type:'dragdrop'},
        { name: 'carta 21', id: 21, card_value: 10 ,target_type:'dragdrop' },
        { name: 'carta 22', id: 22, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 23', id: 23, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 24', id: 24, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 25', id: 25, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 26', id: 26, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 27', id: 27, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 28', id: 28, card_value: 10  ,target_type:'dragdrop'},
        { name: 'carta 29', id: 29, card_value: 10 ,target_type:'dragdrop' },
        { name: 'carta 30', id: 30, card_value: 50 ,target_type:'dragdrop' },
        { name: 'carta de recompenza 1', id: 21 , card_value: 20  ,target_type:'dragdrop'},
        { name: 'carta de recompenza 2', id: 22 , card_value: 20  ,target_type:'dragdrop'},
        { name: 'carta de recompenza 3', id: 23 , card_value: 20 ,target_type:'dragdrop' },
        { name: 'carta de recompenza 4', id: 24 , card_value: 30 ,target_type:'dragdrop' },
        { name: 'carta de recompenza 5', id: 25 , card_value: 30  ,target_type:'dragdrop'},
        { name: 'carta de recompenza 6', id: 26, card_value: 30   ,target_type:'dragdrop'},
        { name: 'carta de recompenza 7', id: 27, card_value: 30   ,target_type:'dragdrop'},
        { name: 'carta de recompenza 8', id: 28, card_value: 50   ,target_type:'dragdrop'},
        { name: 'carta de recompenza 9', id: 29, card_value: 50  ,target_type:'dragdrop' },
        { name: 'carta de recompenza 10', id: 30, card_value: 50  ,target_type:'dragdrop' }
      ];
      </pre></code>
      <p> lo cual me resulta tremendamente innecesario, en especial teniendo en cuenta que casi todas las cartas son la misma y solo tengo 2 cartas con efectos unicos.</p>
      <p> lo bueno de tener un mazo central es que puedo pedirle datos de las cartas con solo darle su id.</p>
      <p> por ejemplo: con este codigo puedo seleccionar un id y obtener todos sus datos </p>
      <pre><code>
        var results = todas_las_cartas.filter(function (nickname) { return nickname.id == 5; });
        var firstObj = (results.length > 0) ? results[0] : null;
        console.log(" nombre: "+firstObj.name);
        console.log(" id: "+firstObj.id);
        console.log(" card_value: "+firstObj.card_value);
        console.log(" target_type: "+firstObj.target_type);
        
      </pre></code>
      <p> o con este codigo puedo crear un nuevo array filtrando solo los elementos cuyo target_type sea dradrop2</p>
      <pre><code>
        var results = todas_las_cartas.filter(function (nickname) { return nickname.target_type == 'dragdrop2'; });
        console.log(results);
      </pre></code>
      <p> asi que use este codigo para cambiar la manera en la que se selecciona el mazo inicial</p>
      <pre><code>
        var cartas_iniciales = ["carta 1", "carta 2", "carta 3", "carta 3", "carta 3", "carta 3"];
      
        var i=1;
        var mazo_inicial = [];
        cartas_iniciales.forEach(crear_mazo_inicial);
        function crear_mazo_inicial(item, index) {
          var filter_results = todas_las_cartas.filter(function (carta) { return carta.name == item; });
          var firstObj = (filter_results.length > 0) ? filter_results[0] : null;
          mazo_inicial.push(firstObj);
      }
      console.log(mazo_inicial);
      </pre></code>
      <p> y al parecer funciona perfecto, esto es bueno por que puedo tener cartas repetidas y asi puedo reducir el mazo total.</p>
      

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.20 - filtro de efectos  </h2>
      <p style=" color: #a0aec1bf;"> 13/4/2020</p>
      <p> Esto ya esta tomando forma, lo qe puedo hacer ahora es agregar una especie de filtro con efectos, para poder variar un poco el efecto de las cartas, podria ser  por ejemplo un filtro por id.
        la funcion toma el id de la carta dropeada y revisa entre la lista de efectos para determinar que es lo que hace.
      </p>
      <pre><code>
        if( card_ID == 1){  vida_jugador = vida_jugador + 20; }
        else if( card_ID == 2){  robar_carta();robar_carta() }
      </pre></code>
      <p> por ahora el filtro funciona solo en las cartas globales.Porque se me dificulta cambiar los valores de la vida de los personajes despues de pasarlos por la funcion,
        quizas deberia convertir todas las funciones de la vida de enemigos en variables globales para que no se tan complicada la transicion.
      </p>      
      <h3> texto de efecto </h3>
      <p> el problema es que ahora las cartas tienen efectos pero no puedo saberlo antes de usarlo.</p>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.19 - cartas con target global  </h2>
      <p style=" color: #a0aec1bf;"> 12/4/2020</p>
      <p> por el momento solo tengo cartas de daño, necesito agregar cartas que curen al jugador, cartas de escudo y eventualmente cartas de basura y maldiciones.</p>
      <p> se me ocurre que para eso voy a necesitar otra funcion drop y otras cartas en la mano, basados en algun parametro.</p>
      <p> para empezar voy a crear un div para el grafico de el jugador.</p>
      <pre><code>
      &ltdiv id="jugador">&lt/div>
      </pre></code>
      <p> ahora tengo que agregar una funcion que permita que las cartas que dropeen en el div de jugador llamen a un alert.</p>
      <pre><code>
        $(function() {
             $('.dragdrop2').draggable({
               revert: true,
               placeholder: true,
               droptarget: '.drop2',
               drop: function(evt, droptarget) {
               
                  $(this).appendTo(droptarget).draggable('destroy');

                  alert(" drop 2")

                  $('.drop2').find('.dragdrop2').remove(); // borra los elementos una vez dentro de el drop
                   
                }
            });
        });
        </pre></code>
        <p> pero para eso tengo que hacer que algunas cartas tengan otra clase. Puedo hacer esto agregano cartd_types, como cartas de ataque y cartas de curacion</p>
        <p> pensandolo mejor, esto de que el jugador en si sea el target quizas no sea una buena idea, a no ser que mas tarde implemente varios jugadores. Por el momento deberian existir 2 tipos de cartas, las cartas 
          que tienen un enemigo especifico como target y las que son mas generales, los card types pueden usarse para otras cosas como separar echizos de acciones o armas.
        </p>
        <p>Por el momento lo resolvi con un pequeño if, para que solo la carta con id 1 sea una carta que se activa sin un objetivo.</p>
        <pre><code>
          if( card_id== 1 ){
              $("#mano").append('&ltcarta  id="'+ card_id +'" name="'+ card_name +'"  card_value="'+ card_value +' " class="dragdrop2">'+ card_name +'&lt/carta>');
            }
            else{
              $("#mano").append('&ltcarta  id="'+ card_id +'" name="'+ card_name +'"  card_value="'+ card_value +' " class="dragdrop">'+ card_name +'&lt/carta>');
          }
         </pre></code>
        <h3> cartas de curacion</h3>
        <p> ahora que tengo cartas que se activan en el tablero en lugar de el enemigo, puedo hacer cartas que afecten al jugador, por ejemplo cartas de curacion</p>
        <p> solo tengo que hacer que si dropeo la carta con id 1, en lugar de quitarle vida al enenemigo le dara 20 de vida al jugador </p>
         

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.18 - card value  </h2>
      <p style=" color: #a0aec1bf;"> 10/4/2020</p>
      <p> Por el momento es imposible ganar por que todas las cartas hacen 10 de daño.</p>
      <p> se me ocurren 2 maneras de afrontar esto, por una parte puedo darles a las cartas un atributo llamado value o damage_value o quizas podria filtrar la carta por id cuando se use en drop y asi saber cual es su valor.</p>
      <p> primero tengo que ver como se muestran las cartas en cada lista para saber como agregar el nuevo atributo.</p>
      <pre><code>
       // carta declarada en el mazo_inicial
       { name: 'carta 1', id: 1 }
    
       //despues se pasa al mazo 
       &ltli class='hand_card' name='"+ item.name +"' id='"+ item.id +"'> "+ item.name +" &lt/li>
       
       //se roba la carta
       &ltcarta  id="'+ card_id +'" name="'+ card_name +'" class="dragdrop">'+ card_name +'&lt/carta>
     
       //pila de descarte
       &ltli class='pila_descarte_card' name='"+ card_name +"' id='"+ card_ID +"' >"+ card_name + "&lt/li>
    
      </pre></code>
      <p> ... </p>
      <pre><code>
        // tuve que agregar el atributo card_value a todas las cartas de el mazo inicial.
        { { name: 'carta 1', id: 1, card_value: 10 },
    
        // argege card_value a el div donde se muestra el mazo inicial en la pantalla de personaje seleccionado
        function myFunction(item, index) {
            document.getElementById("mazo_inicial_div").innerHTML += "id: "+ item.id +" name: "+ item.name +"   card value:"+ item.card_value +"&lt/br>"; 
        }
    
        // agregado en la funcion que muestra el mazo inicial y una copia exacta dentro de volver_seleccion_enemigos (para que este listo para el suigiente match )
        mazo_jugador.forEach( function(item, index) {
            document.getElementById("mazo").innerHTML += "&ltli class='hand_card'  name='"+ item.name +"' id='"+ item.id +"' card_value='"+ item.card_value +"'> "+ item.name +" &lt/li>";
        });
    
        //agregado en las cartas de recompenza
        { name: 'carta de recompenza 9', id: 29, card_value: 50  },
        
        // show_victory_screen() en la funcion que muestra las cartas.
        for (i = 0; i < player_loot; i++) {
            document.getElementById("recompenzas").innerHTML +='&ltdiv onclick="agregar_carta(\''+cartas_recompenza[i].name+'\','+cartas_recompenza[i].id+','+ cartas_recompenza[i].card_value +') , volver_seleccion_enemigos()">'+cartas_recompenza[i].name+' &lt/div>';
        }
        
        //tuve que agregar un atributo extra "c" para que el array que agrega la funcion al mazo permanente tuviera card_value
        function agregar_carta(a,b,c ) {
            mazo_permanente.push({ name: a, id: b , card_value: c });
            //resto del codigo
        }
    
        // se muestra el la lista de cartas a borrar
        document.getElementById("mazo_a_borrar").innerHTML += "&ltli class='to_delete_card'  onclick='borrar("+ index +")'  name='"+ item.name +"' id='"+ item.id +" ' card_value='"+ item.card_value +"'> "+ item.name +" &lt/li>";
    
        //se muestra en la funcion robar
        var card_value = $('#mazo li:first-child').attr('card_value'); // name de el primer li
        $("#mano").append('&ltcarta  id="'+ card_id +'" name="'+ card_name +'"  card_value="'+ card_value +' " class="dragdrop">'+ card_name +'&lt/carta>');
    
        // en la funcion drop ,para hacer daño  y despues para enviarlo a la pila de descartes
        var card_value = evt.target.attributes.card_value.value;
        var enemy_health = enemy_health - card_value;
        $("#pila_de_descarte").append( "&ltli class='pila_descarte_card' name='"+ card_name +"' id='"+ card_ID +"'card_value='"+ card_value +"' >"+ card_name + "&lt/li>");
    
        //en re_mezclar
        for(var i = 0; i < elements.length; i++){
         data.push("&ltli class='hand_card'  name='"+elements[i].attributes.name.value+"' id='"+elements[i].id+"' card_value='"+elements[i].attributes.card_value.value+"'>"+elements[i].innerHTML+"&lt/li>");
        }
        //lo mismo en new_turn
        for(var i = 0; i < elements.length; i++){
         data.push("&ltli class='pila_descarte_card'  name='"+elements[i].attributes.name.value+"' id='"+elements[i].id+"'  card_value='"+elements[i].attributes.card_value.value+"'>"+elements[i].innerHTML+"&lt/li>");
        }
       
    
    </pre></code>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.17 - pantalla de derrota  </h2>
      <p style=" color: #a0aec1bf;"> 9/4/2020</p>
      <p>por el momento perder no significa nada, ademas es dificil perder en si mismo, eventualmente voy a necesitar mejorar la IA de los enemigos, pero por el momento voy a hacer que tener 170 active la funcion derrota.</p>
      <pre><code>
      if( vida_jugador <= 170 ){ 
        alert("muerto")
      }
      </pre></code>
      <p>bien, ahora hay que crear la funcion derrota() y un modal.Por el momento el boton de la pantalla de victoria reinicia la pagina, eventualmente me gustaria que llevara al inicio de la app sin reiniciar todo.</p>
      <p> tambien quiero que halla una barra de experiencia para desbloquear cartas disponibles.</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.16 - barra de vida de el jugador  </h2>
      <p style=" color: #a0aec1bf;"> 9/4/2020</p>
      <p> todo funciona perfectamente, ahora seria hora de empezar con el daño hacia el jugador y las inteligencias artificiales simples.</p>
      <p> mi idea es crear un sistema basao en personalidades, si un enemigo tiene una personalidad defensiva puede actuar distitno a un enemigo con personalidad agresiva, eso es para los enemigos simples.
        Los enemigos mas complejos podrian tener mazos de cartas diferentes dependiendo de sus personalidades.
      </p>
      <p> empecemos con lo basico, una variable que almacene la  vida de el jugador y restarle 10 puntos por cada vez que el enemigo ataca.</p>
      <pre><code>
      vida_jugador = vida_jugador-10;
      console.log("vida jugador: " + vida_jugador);
      </pre></code>
      <p> bien, eso funciona perfecto. ahora en lugar de mostrarlo en un alert vamos a mostrarlo en un div. </p>
      <pre><code>
      document.getElementById("pdv_player").innerHTML= vida_jugador;// vida de el jugador
      </pre></code>
      <h3> barra de vida </h3>
      <p> para hacer que se tranforme en una barra de vida, solo tengo que agregar este pequeño codigo.</p>
      <pre><code>
      var porcentaje_pdv_jugador = parseInt(vida_jugador)/parseInt(max_vida_jugador)*100;
        
      $("#pdv_player").css({'color':'white','width': porcentaje_pdv_jugador +"%" ,'background':'#ff1700'});//cambiar el css 
      </pre></code>
      <h3> distintos puntos de vida por personaje. </h3>
      <p> las variables hay que declararlas globalmente, asi que despues se puede cambiar el numero con los personajes.</p>

       


      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.15 - borrar cartas  </h2>
      <p style=" color: #a0aec1bf;"> 8/4/2020</p>
      <p> la seccion de recompenzas ya funciona bastante bien, lo que me gustaria agregarle ahora es una manera de borrar cartas de el mazo y que se refleje el las subsecuentes batallas.</p>
      <p> para eso voy a agregar por el momento un boton en la seccion de victoria que me permita quitar una carta  el cual va a llamar una funcion que me permita ver un div en donde voy a mostrar el mazo permanente.</p>
      <pre><code>
       mazo_permanente.forEach( function(item, index) {
        document.getElementById("mazo_a_borrar").innerHTML += "&ltli class='to_delete_card'  onclick='borrar("+ index +")'  name='"+ item.name +"' id='"+ item.id +"'> "+ item.name +" &lt/li>";
       });
      </pre></code>
      <p> y despues un pequeño codigo que borre de el array el index seleccionado.</p>
      <pre><code>
        function borrar(e) {
        mazo_permanente.splice(e, 1);
        volver_seleccion_enemigos();
        }
        </pre></code>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.14 -  cartas de recompenza </h2>
      <p style=" color: #a0aec1bf;"> 6/4/2020</p>
      <p> despues de cada batalla la pantalla de victoria deberia dar la opcion de agregar una carta al mazo o quitar una.</p>
      <p> para hacer eso supongo que voy a necesitar una tercera copia de el mazo, tengo el mazo inicial, el que uso para jugar que puede ser modificado dentro de la partida y ahora necesito uno que 
        pueda guardar modificiaciones permanentes y no sea afectado por cartas basura o cambios temporales.
      </p>
      <p> este mazo tambien puede ser accesible en la navbar, para saber que cartas hay.</p>
      <h3>Clonando el mazo </h3>
      <p> lo primero que tengo que hacer es clonar el mazo inicial en una variable que voy a llamar permanent_deck ..o algo asi.</p>
      <pre><code>
      var mazo_permanente; //la variable debe declararse globalmente
      mazo_permanente = mazo_inicial.slice();//clona el mazo_jugador pero de manera independiente.
      </pre></code>
      <p> despues tengo que hacer que cada vez que inicia una partida el contenido de el mazo jugador sea un clon de el mazo permanente</p>
      <pre><code>
      var mazo_jugador = mazo_permanente.slice();//clona el mazo_permanente pero de manera independiente.
      mazo_jugador.sort(function() {return Math.random() - 0.5});
      </pre></code>
      <h3>Agregando carta</h3>
      <p> ahora tecnicamente podria crear un boton que agrege una carta nueva a la variable mazo_permanente al terminar la partida. </p>
      <pre><code>
      function agregar_carta() {
        mazo_permanente.push({ name:'carta 11', id: 31 });
      }
      </pre></code>
      <p> podria llegar a aparecer problemas por agregar siempre cartas con el mismo id... quizas deberia cambiar el id por card_id o algo asi y usar el verdadero id con un contador que agrege un id unico y especifico a esa carta al ser agregada al mazo,
        de esa manera podria agregar cambios especificos a ciertas cartas.
      </p>
      <p> un pequeño problema es que la carta nueva siempre aparece al final del mazo, eso se solucciona mezclando el mazo jugador despues de llamar a la funcion agregar carta </p>
      <pre><code>
      var mazo_jugador = mazo_permanente.slice();//clona el mazo_permanente pero de manera independiente.
      mazo_jugador.sort(function() {return Math.random() - 0.5});
      </pre></code>
      <p> bien, ya funcion perfectamente aunque por el momento solo puede agregar la misma carta una y otra vez.</p>
      <h3>Carta aleatoria</h3>
      <p> en lugar de mostrar una y otra vez la misma carta para agregar al mazo, mi idea es crear listas de cartas por rareza y dependiendo la dificultad de el combate dar un mejor premio.</p>
      <p> pero por el momento, simplemente voy a iniciar con una lista de 2 cartas, y una probabilidad de el 50% de recibir una u otra.</p>
      <pre><code>
      var aleatorio = Math.round(Math.random()*10);
      console.log(aleatorio);
      if( aleatorio < 5 ){
        mazo_permanente.push({ name:'carta 11', id: 31 });
      }
      else{
        mazo_permanente.push({ name:'carta 12', id: 32 });
      }
      </pre></code>
      <h3> Mostrar carta a agregar </h3>
      <p> ahora lo ideal seria que la funcion que selecciona la carta aleatoria se muestre en la pantalla de victoria para saber si vale la pena agregarla o no (tambien para saber que carta es).</p>
      <p> para hacer eso necesito 2  variables que almacenen los datos de carta a agregar, carta_a_agregar_nombre y carta_a_agregar_id (mas adelante puedo pensar en una soluccion mas elegante).Las variables deben ser declaradas globalmente.</p>
      <p> una vez agregadas las variables, dentro de show_victory_screen() se puede agregar el siguiente codigo</p>
      <pre><code>
      carta_a_agregar_nombre = "carta 11";
      carta_a_agregar_id = 31;
      document.getElementById("carta_a_agregar").innerHTML = "name:"+ carta_a_agregar_nombre+", id: "+ carta_a_agregar_id +";";
      </pre></code>
      <p> y luego en la funcion agregar_carta </p>
      <pre><code>
      mazo_permanente.push({ name: carta_a_agregar_nombre, id: carta_a_agregar_id });
      </pre></code>
      <p> ahora puedo conbinarla con el codigo de 50% de probabilidad</p>
      <pre><code>
      var aleatorio = Math.round(Math.random()*10);
      console.log(aleatorio);
      if( aleatorio < 5 ){
         carta_a_agregar_nombre = "carta 11";
         carta_a_agregar_id = 31;
      }
      else{
         carta_a_agregar_nombre = "carta 12";
         carta_a_agregar_id = 32;
      }
      document.getElementById("carta_a_agregar").innerHTML = "name:"+ carta_a_agregar_nombre+", id: "+ carta_a_agregar_id +";";
      </pre></code>
      <p> se que no es la mejor solucion, pero puedo optimizarlo mas tarde.</p>
      <h3>Mostrar varias cartas </h3>
      <p> ok, volvamos a lo basico. La idea final es tener 3 cartas aleatorias dependiendo de la rareza, y que al cliquearlas las otras desaparezcan y la seleccionada se agrege al mazo.</p>
      <p> la version actual solo te muestra 1 de 2 cartas aleatorias, asi que vamos a empezar desde el final otra vez, por el momento voy a dejar de lado el codigo anterior y a mostrar hardcodeadas 3 cartas con alerts.</p>
      <pre><code>
      &ltdiv id="recompenzas">
        &ltp onclick="alert('carta 1'),volver_seleccion_enemigos()" > carta 1  &lt/p> 
        &ltp onclick="alert('carta 2'),volver_seleccion_enemigos()" > carta 2  &lt/p>
        &ltp onclick="alert('carta 3'),volver_seleccion_enemigos()" > carta 3  &lt/p>
      &lt/div>
      </pre></code>
      <p> ahora podemos reemplazar los alerts por la funcion con agregar_carta con 2 parametros para name e id.</p>
      <pre><code>
      &ltdiv id="recompenzas">
        &ltp onclick="agregar_carta('carta 11', 31),volver_seleccion_enemigos()" > carta 11 &lt/p> 
        &ltp onclick="agregar_carta('carta 12', 32),volver_seleccion_enemigos()" > carta 12 &lt/p>
        &ltp onclick="agregar_carta('carta 13', 33),volver_seleccion_enemigos()" > carta 13 &lt/p>
      &lt/div>
      </pre></code> 
      <p> tambien hay que cambiar la funcion agregar_carta para que acepte estos parametros. </p>
      <pre><code>
      function agregar_carta(a,b) {
           mazo_permanente.push({ name: a, id: b });
           // resto de la funcion
       }
      </pre></code>
      <p> esto funciona perfecto, pero esta hardcodeado, para hacer la transicion mas fluida simplemente voy a poner un inner html con la misma informacion </p>
      <p>problema: on click inside innerhtml </p><pre><code>
      document.getElementById("recompenzas").innerHTML='&ltdiv onclick="agregar_carta(\'carta 11\',31),volver_seleccion_enemigos()"> carta 11 &lt/div>';
      document.getElementById("recompenzas").innerHTML+='&ltdiv onclick="agregar_carta(\'carta 12\',32),volver_seleccion_enemigos()"> carta 12 &lt/div>';
      document.getElementById("recompenzas").innerHTML+='&ltdiv onclick="agregar_carta(\'carta 13\',33),volver_seleccion_enemigos()"> carta 13 &lt/div>';
      </pre></code>
      <p> bien, ya pude copiar lo hardcodeado, es hora de hacerlo mas dinamico.</p>
      <p> la variable aleatorio  genera un numero entre 0 y 10, luego la carta recompenzas muestra una carta con ese id y nombre. podria crear una funcion asi y llamarla 3 veces.</p>
      <pre><code>
      var aleatorio = Math.round(Math.random()*10);
      document.getElementById("recompenzas").innerHTML+='&ltdiv onclick="agregar_carta(\'carta '+aleatorio+'\','+aleatorio+'),volver_seleccion_enemigos()"> carta '+aleatorio+' &lt/div>';
      </pre></code>
      <p> se puede cambiar el codigo para que muestre un numero entre 1 y 100, pero despues en la funcion agregar carta hay que limpiar el inner html de  recompenzas</p>
      <pre><code>
      var aleatorio = Math.round(Math.random() * (100 - 1) + 1);
      document.getElementById("recompenzas").innerHTML ='&ltdiv onclick="agregar_carta(\'carta '+aleatorio+'\','+aleatorio+'),volver_seleccion_enemigos()"> carta '+aleatorio+' &lt/div>';
      var aleatorio = Math.round(Math.random() * (100 - 1) + 1);
      document.getElementById("recompenzas").innerHTML +='&ltdiv onclick="agregar_carta(\'carta '+aleatorio+'\','+aleatorio+'),volver_seleccion_enemigos()"> carta '+aleatorio+' &lt/div>';
      var aleatorio = Math.round(Math.random() * (100 - 1) + 1);
      document.getElementById("recompenzas").innerHTML +='&ltdiv onclick="agregar_carta(\'carta '+aleatorio+'\','+aleatorio+'),volver_seleccion_enemigos()"> carta '+aleatorio+' &lt/div>';
      </pre></code>
      <p> bien, ahora voy a necesitar una lista de cartas de las cuales sacar los datos, para que no sean simplemente un numero repetido en nombre e id.</p>
      <pre><code>
      cartas_recompenza = [
        { name: 'carta de recompenza 1', id: 21 },
        { name: 'carta de recompenza 2', id: 22 },
        { name: 'carta de recompenza 3', id: 23 },
        { name: 'carta de recompenza 4', id: 24 },
        { name: 'carta de recompenza 5', id: 25 },
        { name: 'carta de recompenza 6', id: 26 },
        { name: 'carta de recompenza 7', id: 27 },
        { name: 'carta de recompenza 8', id: 28 },
        { name: 'carta de recompenza 9', id: 29 },
        { name: 'carta de recompenza 10', id: 30 }
      ];
      val_max = cartas_recompenza.length - 1; // el -1 es para que se incluya el 0 de length
        
      var aleatorio = Math.round(Math.random()* val_max );
      document.getElementById("recompenzas").innerHTML ='&ltdiv onclick="agregar_carta(\''+cartas_recompenza[aleatorio].name+'\','+cartas_recompenza[aleatorio].id+'),volver_seleccion_enemigos()">'+cartas_recompenza[aleatorio].name+' &lt/div>';
      var aleatorio = Math.round(Math.random()* val_max );
      document.getElementById("recompenzas").innerHTML +='&ltdiv onclick="agregar_carta(\''+cartas_recompenza[aleatorio].name+'\','+cartas_recompenza[aleatorio].id+'),volver_seleccion_enemigos()">'+cartas_recompenza[aleatorio].name+' &lt/div>';
      var aleatorio = Math.round(Math.random()* val_max );
      document.getElementById("recompenzas").innerHTML +='&ltdiv onclick="agregar_carta(\''+cartas_recompenza[aleatorio].name+'\','+cartas_recompenza[aleatorio].id+'),volver_seleccion_enemigos()">'+cartas_recompenza[aleatorio].name+' &lt/div>';
      </pre></code>
      <p> ahora tengo que hacer que todo esto sea una funcion que se repite dependiendo la cantidad de loot que el personaje tenga asignado. y que los numeros no puedan repetirse.</p>
      <p> creo que para que no se repitan los numeros la mejor idea es mezclar el array de recompenzas y simplemente repetir la funcion que muestra el inner la cantidad de veces que la variable de loot me permita
         sumando i++ por cada vez que se repita y mostrando la siguiente carta y asi.
      </p>
      <pre><code>
        var player_loot; //esta funcion hayq ue declararla globlamente  
        cartas_recompenza = [
           { name: 'carta de recompenza 1', id: 21 },
           { name: 'carta de recompenza 2', id: 22 },
           { name: 'carta de recompenza 3', id: 23 },
           { name: 'carta de recompenza 4', id: 24 },
           { name: 'carta de recompenza 5', id: 25 },
           { name: 'carta de recompenza 6', id: 26 },
           { name: 'carta de recompenza 7', id: 27 },
           { name: 'carta de recompenza 8', id: 28 },
           { name: 'carta de recompenza 9', id: 29 },
           { name: 'carta de recompenza 10', id: 30 }
        ];
        //mezcla las cartas
        cartas_recompenza.sort(function() {return Math.random() - 0.5});
        
        var i;
        for (i = 0; i < player_loot; i++) {
          document.getElementById("recompenzas").innerHTML +='&ltdiv onclick="agregar_carta(\''+cartas_recompenza[i].name+'\','+cartas_recompenza[i].id+'),volver_seleccion_enemigos()">'+cartas_recompenza[i].name+' &lt/div>';
        }
        </pre></code>

       



      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.13 - volver a "enemigos"  </h2>
      <p style=" color: #a0aec1bf;"> 3/4/2020</p>
      <p> Ahora mismo, una vez que se vence al slime se caba el juego, aparece la pantalla de victoria y no se puede hacer nada mas.</br>
      podria hacer que el codigo vuelva a la seleccion de personajes. pero me parece una mejor idea crear una seccion de seleccion de enemigo.
      </p>
      <p> Primero tengo que crear la seccion seleccion_de_enemigos, y despues tengo que crear una funcion que se llama go_to_seleccion_de_enemigos y reemplazarlo por play en la seccion personaje seleccionado </p>
      <h3>Post-victoria</h3>
      <p> Ahora puedo hacer un boton que me devuelva a la seleccion de enemigos una vez terminada la pelea.</p>
      <p> el unico problema es que hay que limpiar la mano, la pila de desacartes y volver a mezclar el mazo.</p>

      
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.12 -  pantalla de victoria </h2>
      <p style=" color: #a0aec1bf;"> 3/4/2020</p>
      <p>Me molestaba mucho el alert que aparecia cuando se vence a todos los enmigos, asi que hize un modal, el div interno sigue siendo provisorio, y creo que deveria tener un pequeño delay.
        Pero es mejor que lo que tenia antes. </p>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.11 - limite de carta en mano  </h2>
      <p style=" color: #a0aec1bf;"> 3/4/2020</p>
      <p> hasta el momento la funcion new_turn() roba 3 cartas, independientemente de el contexto. pero para poder hacerlo dinamico y para poder darle mas personalidad a los 3 arquetipos que arme. Voy a 
        darles 3 numeros distintos de cartas en mano.
      </p>
      <p> tambien mejore la funcion para que robe cartas cada medio segundo.</p>
      <pre><code>
        var i = 0;
        var separador= 500;
        var max_hand_Size = 3; 
        for (i = 0; i < 3; i++ ) {
           setTimeout(robar_carta, separador);
           separador = separador + 500;
        };
        </pre></code>
      <p> la variable max_hand_size, hay que declararla  globalmente  pero hay que asignarle  el valor dentro de el personaje </p>




      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.10 - creando enemigos dinamicamente </h2>
      <p style=" color: #a0aec1bf;"> 2/4/2020</p>
      <p>La funcion aleatoria que estaba usando para  mostrar a los enemigos puede llegar a a ser util, pero no es lo que necesito.Lo que necesito es que los paramentros de la funcion show_enemy() sean los id de los enemigos que voy a enfrentar.</p>
      <p> para eso necesito que la funcion se repita por la cantidad de parametros y que muestre a los enemigos correspondientes</p>
      <pre><code>
       function show_enemy(a) {
            var i;
            for(i = 0; i < arguments.length; i++) {
               a = arguments[i];
               if ( a == "enemy_1" ) { innerHTML+= // mostrar enemy 1 }
               if ( a == "enemy_2" ) { innerHTML+= // mostrar enemy 2 }
           }
       }
      </pre></code>
      <p> lo que puedo hacer es crear una lista de enemigos y una funcion que filtre a los enemigos por id. ej: https://www.codereadability.com/replacing-if-statements-with-object-lookups/ </p>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.9.2 - eliminando enemigos </h2>
      <p style=" color: #a0aec1bf;"> 1/4/2020</p>
      <p> primero: cuando la vida de una enemigo llege a 0 tengo que eliminar el correspondiente elemento enemy</p>
      <pre><code>
        if( enemy_health <= 0 ){ 
            $("#"+droptarget.id).remove();
        }
      </pre></code>
      <h3> pantalla de victoria </h3>
      <p> una vez muertos todos los enemigos deberia redireccionarse a la pantalla de victoria, eso se puede hacer agregando estos renglones al codigo anterior </p>
      <pre><code>
      var enemys_length = $("#enemys enemy").length;
      if(enemys_length == 0 ){  // mostrar pantalla de victoria}
      </pre></code>
      <h3> mejorando la barra de vida </h3>
      <p> al bajar la barra de vida se actualiza el width</p>
      <pre><code>
      $("#pdv_"+droptarget.id).css({'color':'white','width': enemy_health +"%" ,'background':'#ff1700'});//cambiar el css de el droptarget
      </pre></code>
        

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.9.1 - numero de vida </h2>
      <p style=" color: #a0aec1bf;"> 1/4/2020</p>
      <p> siguiendo con la version de el codigo anterior, decidi que lo mejor es usar la version que utiliza los atributos para almacenar la vida actual delenemigo,
        quizas lo conbine con la idea  de tener un filtro de los stats de los enemigos. Pero por ahora me conformo con ver barras de vida.
      </p>
      <h3> numero de vida </h3>
      <p> dentro de cada enemy cree un div con el id enemy1_health_number ... , es el id de el enemigo seguido por heath_number, eventualmente puedo cambiarlo por algo que valla mas con barras de vida.</br>
      En fin, este pequeño codigo en query me deja cambiar el contenido de el div por el resultado de la cuenta del codigo anterior.
      </p>
      <pre><code>
      $("#"+droptarget.id+"_health_number").html( enemy_health);
      </pre></code>
      <p> esto significa que automaticamente todos los enemigos tienen numeros que representan sus puntos de vida individuales, aunque por el momento no succede nada si los numeros llegan a 0.</p>
      <p> lo que tendria que hacer ahora es un if, que revise si entre todos los enemigos, si todos tienen 0 puntos de vida gane la pelea, tambien tengo que ver la manera de destruir o volver inutil los enemys muertos</p>
    
    

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.9 - barras de vida rival </h2>
      <p style=" color: #a0aec1bf;"> 31/3/2020</p>
      <p> creo que ahora si es finalmente el momento para crear las barras de vida</p>
      <p> lo que tengo que determinar es como voy a hacer para que cada rival tenga su propia barra de vida, imagino que ya en la funcion que crea al enemigo deberia crearlas.</p>
      <p> se me ocurren 2 maneras de lograr esto </p>
      <h3> opcion 1: usar atributos </h3>
      <p> puedo usar el echo de que ya recibo el id de el drop.target en  la funcion drop y usarlo para buscar el atributo health </p>
      <pre><code>
      var enemy_health = droptarget.attributes.health.value;
      </pre></code>
      <p> y despues una vez que tenga ese valor puedo restarle la cantidad de daño que haga la carta y despues cambie el valor del atributo. </p>
      <pre><code>
      var enemy_health = enemy_health-10;
      document.getElementById(droptarget.id).setAttribute("health", enemy_health );
      console.log(enemy_health); // salud de el enemigo
      </pre></code>
      <p> el problema es que si despues quiero agregar opciones como que el rival recupere toda su salud o algo asi, necesitaria otro atributo especificamente para almacenar la sauld inicial de el rival.</p>
      <h3> opcion 2: usar variables </h3>
      <p> supongo que podria poner una lista de variables y filtrarlas por el id de la dropzone, seria como un bestiario y dependiendo el monstruo podria conseguir datos como su hp inicial y su hp actual o su resistencia and stuff </p>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.8 - ataque rival </h2>
      <p style=" color: #a0aec1bf;"> 30/3/2020</p>
      <p> ahora que hay un boton para finalizar el turno deberia empezar a trabajar en el turno del rival.Por ejemplo, 
        si el turno de el rival comenzo deberia contar la cantidad de enemigos en el tablero, y ejecutar una accion por cada uno. en este caso atacar.
      </p>
      <pre><code>
      function turno_enemigo(){
        var enemys_ids = $('#enemys enemy').map(function(){
          return $(this).attr('id');
        }).get();
                      
        enemys_ids.forEach( function( element ) {
          alert("ataque de  " + element);
        });
      } 
       </pre></code>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.7 - desabilitar cartas en turno enemigo </h2>
      <p style=" color: #a0aec1bf;"> 30/3/2020</p>
      <p> ahora que las cartas se roban automaticamente y se van de la mano al final de cada turno, estaba pensando que las cartas deberian quedarse en la mano hasta el inicio de el suguiente turno de usuario,
        asi que me parece que para aclarar eso primero tengo que crear turnos.
      </p>
      <p> en su forma mas basica el turno enemigo deberia ser una funcion que quita la interactividad a las cartas en la mano la cual vuelve junto con la nueva mano al turno siguiente. </p>
      <p> para hacer eso primero necesito saber cuales son las cartas que tengo en la mano, y no puedo usar el mismo codigo que uso para pasar las cartas de la mano a la pila de descartes por que estas se basan en
        encontrar cuantos elementos con la classe draggable existen.
      </p>
      <p> asi encontre este codigo el cual crea un array de los elemento child de un padre.( quizas me convenga cambiar algunos de los codigos anteriores para encontrar elementos por este)</p>
      <pre><code>
      //var cartas_en_mano =  $("#mano > carta").length
      var cartas_en_mano =  $("#mano > carta").id;
      console.log(cartas_en_mano);
      </pre></code>
      <p> mi obetivo es descubrir el id de cada una de las cartas en la mano para poder quitarles la classe draggable.</p>
      <pre><code>
        var ids = $('#mano carta').map(function(){
            return $(this).attr('id');
        }).get();
              
        ids.forEach( function( element ) {
             console.log(+element);
             document.getElementById(element).classList.remove("dragdrop");
            document.getElementById(element).classList.remove("draggable");
            document.getElementById(element).classList.remove("dragaware");
         });
        </pre></code>
        <p> logre conseguir los ids de cada una de las cartas en mano y quitarles las classes dragables. pero aun asi funcionan...creo que voy a tener que buscar una alternativa</p>
        <h3> alternativa 1: div transparente</h3>
        <p> esta me parece una soluccion poco elegante. pero puedo colocar un div transparente sobre la mano para evitar interaccion durante el turno rival. la contra es que no permite
          hacer click en la carta para ver detalles o cosas asi.
        </p>
        <h3> alternativa 2: draggables pero inutiles</h3>
        <p>Esta es la version mas plausible, podria simplemente agregar un if dentro de el drop para volver la funcion inutil si es el turno del rival.</p>
        <p> </p>     
        <h3> alternativa 3: clonar la mano</h3>
       <p> existe la opcion de crear un div que clone a la mano y se vea en el mismo lugar de la mano cada vez que sea el turno del oponente</p>
      <p> el pro de esta opcion seria que puedo darle un comportamiento diferente a las cartas en la mano cuando es el turno del rival</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.6.1 - Robar automaticamente </h2>
      <p style=" color: #a0aec1bf;"> 30/3/2020</p>
      <p>la funcion new_turn() ahora me permite robar 3 cartas con medio segundo de diferencia entre cada una, eso da la ilusion de estar robando cartas, pero para eso hay que cliquear un boton.</br>
      Ahora quiero hacer que la funcion new_turn() se aplique automaticamente cuando inicie la partida, para eso necesito llamar a new_turn() al final de la funcion play(). </p>
      <p> sigue existiendo el problema de que la funcion new_turn() roba 3 cartas, numero hardcodeado. Eventualmente voy a necesitar robar hasta llegar al numero de cartas en mano, sea cual sea.</p>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.6 - new_turn</h2>
      <p style=" color: #a0aec1bf;"> 29/3/2020</p>
      <p>al clickear el boton new_turn roba 3 cartas y lleva  las cartas restantes en la mano a la pila de descartes.</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.5.1 - un poco de optimizacion </h2>
      <p style=" color: #a0aec1bf;"> 29/3/2020</p>
      <p>El codigo funciona bien, pero podria ser un poco mas eficiente.Por ejemplo estoy usando varias veces el codigo que actualiza el numero de cartas en el mazo, en la mano y en la pila de descartes.Seria mas conveniente llamar a una funcion llamada actualizar_manos_length() que funcione en esos momentos.</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.5 - lengths y re_mezclar </h2>
      <p style=" color: #a0aec1bf;"> 29/3/2020</p>
      <p> el unico problema con el boton de robar, es que si lo oprimo cuando ya no quedan cartas en el mazo, roba una carta glitch con el nombre undefined. </br>
      Para evitar eso tengo que crear una funcion que se llame cada vez que se intente robar y no halla cartas en el mazo, dicha funcion va a tomar las cartas de la pila de descartes, mezclarlas y depues ponerlas nuevamente en el mao para poder ser robadas.</p>
      <p> antes que nada necesito saber el numero exacto de cartas en el mazo, para eso tengo que darle una clase especifica a las cartas que estan en la mano, en este caso "hand_card". </p>
      <pre><code>
      var mazolength= $("#mazo").find(".hand_card").length;
      document.getElementById("mazo_length").innerHTML=mazolength;
      </pre></code>
      <p> este codigo deberia ejecutarse una vez cuando empieza la partida y luego dentro de robar_carta y re_mezclar.</p>
      <p> ya que tengo el numero de las cartas en mazo, podria hacer lo mismo con las cartas en la mano y en la pila de descarte </p>
      <pre><code>
        var mazolength= $("#mazo").find(".hand_card").length ;
        var manolength= $("#mano").find(".dragdrop").length ;
        var piladedescartelength= $("#pila_de_descarte").find(".pila_descarte_card").length ;
        
        document.getElementById("mazo_length").innerHTML= mazolength;
        document.getElementById("mano_length").innerHTML= manolength;
        document.getElementById("pila_descarte_length").innerHTML= piladedescartelength; 
      </pre></code>
      <p> el codigo quedaria asi, y deberia ejecutarse justo despues de las cartas mecladas entran al mazo, al final de la funcion para robar cartas y al final de la funcion drop, que son las unicas 3 maneras por el momento de cambair el numero de cartas dentro de las 3 listas de cartas.</p>

      <p> ahora tengo que hacer que al empezar una partida automaticamente se ejecute la funcion para robar cartas 3 veces, incluso puedo darle un pequeño delay conbinado con una animacion para simular que se estan robando cartas</p>

      <h3> alert "no quedan cartas"</h3>
      <p> antes de crear la funcion quiero probar si el codigo funciona bien con un alert, basicamente dentro de la funcion robar_carta agrege un if que chequea si el mazo tiene al menos 1 carta, si la tiene roba una carta normalmente, y si no sale el alert. </p>






      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.4 -  mazo y mano </h2>
      <p style=" color: #a0aec1bf;"> 28/3/2020</p>
      <p> llegue a esta seccion de el codigo que estaba evitando por que todo los demas funciona muy bien,
        tengo que  reemplazar el codigo que cree para el mazo, ya que las cartas en el mazo no deberian verse. y crear un boton que me permita robar cartas, osea convertirlas en cartas de la mano.
      </p>
      <p> antes que nada tengo que crear una lista para el mazo y un div para la mano.</br>
      por el momento la mano esta vacia, pero con un ligero cambio al codigo que muestra las cartas desordenadas la lista de el mazo funciona perfectamente.</p>
      <p> ahora tengo que crear un boton que me permita robar cartas.</p>
      <h3> boton para robar cartas</h3>
      <p> para empezar necesito conseguir el id, y el atributo name ( y cualquier otro atributo) </p>
      <pre><code>
      var card_id = $('#mazo li:first-child').attr('id'); // id de el primer li
      var card_name = $('#mazo li:first-child').attr('name'); // name de el primer li
      </pre></code>
      <p> despues el boton de robar cartas tiene que quitar la primera carta de la lista de el mazo</p>
      <pre><code>
      $('#mazo li:first-child').remove();//quita el primer elemento de mazo
      </pre></code>
      <p> cambie la funcion de drop para que este al final de draw_card, tiene mas sentido que este ahi porque no hace falta llamar a la funcion hasta que halla cartas.
      </p>
   

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.3.1 -  lista de descarte y atributo name  </h2>
      <p style=" color: #a0aec1bf;"> 27/3/2020</p>
      <p> para hacer las cosas bien decidi cambiar el innerHTML por el atributo name en la pila de descartes, para eso tuve que modificar como se muestran las cartas en el mazo para que incluyan el atributi name.</p>
      <pre><code>
        // mostrar mazo de el jugador ------------------
        mazo_jugador.forEach( function(item, index) {
            document.getElementById("mazo_jugador_div").innerHTML += "&ltcarta name='"+ item.name +"' id='"+ item.id +"' class='dragdrop' > "+ item.name +" &lt/carta>";
        });
      </pre></code>
      <p> y despues tuve que actualizar la funcion drop con estos codigos </p>
      <pre><code>
        var card_name = evt.target.attributes.name.value;
        
        $("#pila_de_descarte").append( card_name + "&lt/br>");
    </pre></code>
     <h3> Lista ordenada </h3>
     <p> ahora el problema es que la lista de cartas usadas no es realmente una lista, asi que vamos a cambiar eso, primero convertiendo el div pila_de_descarte en una ul y despues cambiar el codigo en el drop a esto:</p>
     <pre><code>
      $("#pila_de_descarte").append( "&ltli>"+ card_name + "&lt/li>");
      </pre></code>
      <p> de esta manera eventualmente los elementos li van a poder almacenar atributos que voy a poder recuperar mas tarde.</p>

      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.3 - pila de descartes   </h2>
      <p style=" color: #a0aec1bf;"> 27/3/2020</p>
      <p> para empezar a darle forma a el verdadero juego tengo que hacer que cada vez que una carta se use, independientemente de en que enemigo se use, la carta pase a formar parte de la lista de cartas usadas.
      </br>Por el momento no voy a hacer nada con esas cartas, pero eventualmente van a remezclarze en el mazo principal.</p>
      <p> primero tengo que crear un div que se llame pila_de_descarte,en el voy a almacenar el nombre de todas las cartas usadas</p>
      <pre><code>
      $("#pila_de_descarte").append(" carta descartada &lt/br>");
      </pre></code>
      <p> simplemente incluyendo este codigo dentro de la funcion del drop crea una lista, cada vez que una carta es usada la frase "carta descartada" aparece dentro. ahora lo que quiero es cambiar eso por el nombre de la carta en si.</p>
     <p> especificamente en esta version el nombre de la carta esta en su innerHTML, pero eventualmente voy a tener que cambiarlo y convertir name en un atributo de las cartas.</p>
     <pre><code>
      $("#pila_de_descarte").append( evt.target.innerHTML + "&lt/br>");
     </pre></code>
     <p> las cartas siguen sin hacer nada, pero al menos la battle_stage esta tomando mas forma.</p>
  
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.2 - enemigos dinamicos  </h2>
      <p style=" color: #a0aec1bf;"> 27/3/2020</p>
      <p> bien, el proyecto esta avanzando muy bien, tengo una seleccion de personajes, mazos independientes de los que se usan para jugar, cartas drageables y varios enemigos dropeables. Pero estos 2 ultimos suceden en la consola, mi meta ahora es crear 2 barras de vida para los 2 slimes y cada carta va a quitarles 10 puntos de vida.  </p>
       <p> creo que la mejor manera de tratar el asunto de las barras de vida es volverlo un atributo del enemigo... o de el personaje mas bien, de esa manera esta automaticamente asignado al personaje en si y no requiero tantas variables llevando la cuenta de los diferentes puntos de vida, o quizas no funciona asi y de todas maneras tengo que usar variables.</p>
      <p> una cosa interesante que puedo hacer es mostrar enemigo aleatorios, con cierta probabilidad de enemigo insuales.</p>
      <h3> mostrar enemigos dinamicamente </h3>
      <p> hasta ahora los enemigos estan hardcodeados, antes que nada tengo que cambiar eso, para de manera dinamica cambiar el enemigo y la cantidad.</p>
      <p> para eso voy a crear una funcion que muestra al enemigo show_enemy(), por ahora la funcionva a estar fuera de la  funcion principal pero creo que eventualmente voy a tener que incluirla despues de la seleccion de personae o algo asi. </p>
      <p> por ahora la funcion solo remplaza el contenido de  el div "enemys" con un elemento harcodeado con una imagen de el slime.</p>
      <pre><code>
       show_enemy();
       function show_enemy() {
        document.getElementById("enemys").innerHTML="&ltenemy class='drop' id='enemy1' style='display: inline-block;'> &ltimg src='https://opengameart.org/sites/default/files/slime_idle_0.gif' alt='slime' height='150' width='auto'> &lt/enemy>";
       }
      </pre></code>
      <p> este es un buen inicio, en especial porque el codigo del drop funciona perfectamente, ahora lo que puedo hacer es crear una probabilidad del 60% de que aparezcan 2 slimes en lugar de 1.</p>
      <pre><code>
        function show_enemy() {
           var aleatorio = Math.round(Math.random()*10);
           console.log(aleatorio);
           if( aleatorio < 6 ){
             // mostrar un enemigo
           }
           else{
            // mostrar 2 enemigos
           }
        }
        </pre></code>
        <p> pero por el momento solo sige mostrando a los enemigo harcodeados, lo cual sirve por el momento pero quiero mejorar.</p>


       <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.2.1 -  droptarget.id </h2>
       <p style=" color: #a0aec1bf;"> 26/3/2020</p>
      <p> ahora que el drag and drop funciona voy a cambiar  el codigo para que ejecute la funcion atacar</p><pre><code>
        $(function() {
            $('.dragdrop').draggable({
               revert: true,
               placeholder: true,
               droptarget: '.drop',
               drop: function(evt, droptarget) {
                   var currentID = evt.target.id;/*- returns  the id. */
                   $(this).appendTo(droptarget).draggable('destroy');
                   $('.drop').find('.dragdrop').remove(); // borra los elementos una vez dentro de el drop
                   
                   atacar();
               }
            });
        });
        </pre></code>        
        <p>Lo que tengo que hacer es crear un segundo slimey boy y ver que al dropear la carta no solo tenga el id de la carta usada, sino el id de el enemigo seleccionado. si no logro esto mi deckbuilder va a tener que ser de enemigos individuales, lo cual no es la idea. </p>
        <h3> segundo slimey boy</h3>
        <p> la verdad crei que iba a ser dificil poque el demo de  <a href="https://github.com/gardiner/draganddrop" >draganddrop.js </a> no muestra eemplos de como diferenciar el receptor del drop. pero con un simple codigo pude reslverlo.</p>
        <pre><code>
         HTML---
         
         &ltenemy class="drop" id="enemy1" style=" display: inline-block; "> &ltimg src="https://opengameart.org/sites/default/files/slime_idle_0.gif" alt="slime" height="150" width="auto"> &lt/enemy>
         &ltenemy class="drop" id="enemy2" style=" display: inline-block; "> &ltimg src="https://opengameart.org/sites/default/files/slime_idle_0.gif" alt="slime" height="150" width="auto"> &lt/enemy>
         
         JS ----
         
         console.log(droptarget.id); // ID  de la dropzone
        </pre></code>
        <p> droptarget.id te da la ID de la dropzone, asi que tambien puedo buscar otros atributos especificos, en este caso podria ser ataque o defensa o incluso si son minions o no. pero lo importante es que cada id va a estar vinculado a una barra de vida especifica.</p>
        <h2 style="border-bottom: solid 2px #eff0f1;"> v 0.2 - drangandrop </h2>
        <p style=" color: #a0aec1bf;"> 25/3/2020</p>
      <p> decidi que en lugar de hacer una barra de vida y bajarla con el boton el siguiente paso va ser hacer las cartas draggabeables y que al  dropearse en el slime llamen a la funcion atacar</p>
      <p>  para hacer que mis cartas sean draggables voy a usar <a href="https://github.com/gardiner/draganddrop" >draganddrop.js </a> <a href="hhttps://www.jqueryscript.net/demo/Mobile-Drag-Drop-Plugin-jQuery/" > demo </a> , es un plugin  para Jquery que funciona incluso en dispositivos mobiles.</p>
      <p> por eso antes de nada voy llamar a jquery y luego voy a crear una carpeta para plugins y llamar desde ahi a dragandrop. </p>
      <pre><code>
        &lt!-- javascript -->
        &ltscript src="https://code.jquery.com/jquery-1.12.4.min.js"> &lt/script>
        &ltscript src='plugins/draganddrop.js' type='text/javascript'> &lt/script>
      </pre></code>
      <p> ya que estoy voy a crear un archivo style.css para darle estilo a las cartas y a la dropzone...quizas despues lo cambie a draganddrop.css o algo asi </p>
      <p> dentro de la seccion battle_stage voy a agregar una dropzone, para que se activen  las cartas</p>
      <pre><code>
        &ltdiv class="drop">&ltp>Drop here&lt/p>&lt/div>
      </pre></code>
      <p> transformo la lista desordenada en cartas.</p>
      <pre><code>
      // mostrar mazo de el jugador ------------------
      mazo_jugador.forEach( function(item, index) {
      document.getElementById("mazo_jugador_div").innerHTML += " &ltcarta id='"+ item.id +"' class='dragdrop' > "+ item.name +"  &lt/carta>";
      })
    </pre></code>
    <p> y por ultimo llamo a esta funcion( importante!! hay que llamar a la funcion despues de el codigo anterior donde se muestra la lista como cartas ) que convierte las cartas en objetos draganddrop.</p>
    <pre><code>
      $(function() {
          $('.dragdrop').draggable({
              revert: true,
              placeholder: true,
              droptarget: '.drop',
              drop: function(evt, droptarget) {
                  var currentID = evt.target.id;/*- returns  the id. */
                  $(this).appendTo(droptarget).draggable('destroy');
                  console.log(currentID);//ejecuta el codigo
                  $('.drop').find('.dragdrop').remove(); // borra los elementos una vez dentro de el drop
              }
          });
      });
  </pre></code>
        <p> bien. Ahora las cartas son draggables y dropeables, aunque por el momento dropear las cartas solo te muestra su id en la consola, la idea ahora es hacer que todas las cartas al dropear llamen a la funcion atacar().</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.1.4 - "Slimey Boy" </h2>
      <p style=" color: #a0aec1bf;"> 25/3/2020</p>
      <p> ahora empieza la parte dificil. no estoy seguro de como diseñar los encuentros con enemigos o como manejar la seleccion de personajes a atacar en el caso de que el numero sea fluctuante y a su vez como manejar sus respectivos puntos de vida. Asi que lo voy a tomar con calma y lo voy a programar poco a poco </p>
      <p> empezemos simple, vamos a crear un enemigo. </p>
      <img src="https://opengameart.org/sites/default/files/slime_idle_0.gif" alt="slime" height="150" width="auto">
      <p> este pequeño slime va a servir de placeholder por el momento. </p>
      <pre><code>
        &ltenemy>&ltimg src="https://opengameart.org/sites/default/files/slime_idle_0.gif" alt="slime" height="150" width="auto"> &lt/enemy>
      </pre></code>
      <p> bien, ahora necesitamos una manera para dañar al adorable bastardo, asi que voy a incluir un boton que daña al slime. </p>
      <pre><code>
        &ltbutton onclick="atacar()" > atacar al slime  &lt/button>
        
        javascript------
        
        function atacar() {
            alert( " 10 de daño al slime ");
        }
        </pre></code>
        <p> porsupuesto esto no signfica nada, es solo un alerte que dice que daño al slime, pero nada esta pasando realmente. el slime esta bien y las cartas no influyenen lo absoluto. Pero es un inicio, ahora puedo agregarle una barra de vida al slime y quitarle realmente 10 puntos de vida cada vez que presiono el boton.</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.1.3 - seccion "battle_stage" </h2>
      <p style=" color: #a0aec1bf;"> 25/3/2020</p>
      <p> por el momento tengo una lista de cartas ordenadas y otra desordenada, claro que sto es solo por el prototipo, en realidad no deberian verse juntas. Asi que voy a cambiar eso.</p>
      <p> voy a crear un tercera seccion a la que voy a llamar escenario de pelea o battle_stage, en esta seccion se va a mostrar el mazo de el jugador mientras que en la seccion de personaje va a quedar la lista incial</p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.1.2 - mazo editable </h2>
      <p style=" color: #a0aec1bf;"> 25/3/2020</p>
      <p> cada personaje tiene su mazo, eso es un avanze. Pero esos mazos son los iniciales. son una lista predeterminada, lo que tengo que hacer ahora es clonar los mazos iniciales para que puedean ser editables durante la partida.</p>
      <pre><code>
        var mazo_jugador = mazo_inicial.slice();
      </pre></code>
      <p> este codigo crea un clon de el mazo incial dentro de la variable "mazo_jugador", y se puede mostrar de la misma manera que el mazo inicial, solo hay que crear un div con la id mazo_jugador_div, y recordar limpiar el div cuando se vuvlve a la selecciond de personajes</p>
    
      <pre><code>
        // mostrar mazo de el jugador ------------------
        mazo_jugador.forEach( function(element, index) {
          document.getElementById("mazo_jugador_div").innerHTML += "id: "+ element.id +" name: "+ element.name +" &lt/br>"; 
        });
      </pre></code>
      <p> bien, ahora tengo 2 copias de el mismo catalogo de cartas. lo importante es que son independientes entre si, por lo cual puedo crear una funcion que mezlce el mazo jugador sin afectar el inicial.</p>
      <pre><code>
      mazo_jugador.sort(function() {return Math.random() - 0.5});
      </pre></code>
      <p> Supongo que en algun momento puedo necesitar una tercera copia que se cree cada vez que quiero revisar el mazo jugador en el medio de un match...pero eso lo vere despues. </p>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.1.1 - Seleccion de personajes </h2>
      <p style=" color: #a0aec1bf;"> 25/3/2020</p>
      <p> lo que quiero hacer ahora es crear una pantalla de seleccion de personajes, dependiendo cual personaje se elija  se va a mostrar un mazo inicial diferente</p>
      <p> ahora supongo que tengo varias opciones para pasar de pantalla, puedo usar un Eventlistener  para cambiar entre distintos divs, puedo usar ajax, o pasar variables por la url.</p>
      <p> primero voy a intentar la opcion de Eventlistener, y si llego a tener problemas puedo ramificar el proyecto desde este punto.</p>
      <h3> v 0.1.1a "Eventlisteners" </h3>
      <p> lo primero que voy a hacer es dividir el programa en 2 secciones, la seccion "seleccion_de_personajes" y la seccion "personaje_seleccionado", una vez creadas estas 2 secciones voy a darle un display:none a "personaje_seleccionado", la idea es que si todo sale bien las secciones van a cambiar entre display none y display inherit</p>
      <p> ahora voy a crear la variable "personajeID" esta variable es importante porque va a determinar que personaje esta seleccionado y eso es lo que se va a mostrar en la siguiente seccion. pero para que el codigo sepa que personaje esta selccionado necesitamos agregar Eventlisteners. </p>
      <pre><code>
      //seleccionar un personaje --------------------------------------------------------------------------------------
      var personajeID;
      document.getElementById("char_1").addEventListener("click", function(){ select_personaje("char_1"); });
      document.getElementById("char_2").addEventListener("click", function(){ select_personaje("char_2"); });
      document.getElementById("char_3").addEventListener("click", function(){ select_personaje("char_3"); });
      </pre></code>
      <p> cada uno de estos Eventlisteners "escucha" si se clickeo el div con el id correspondiente y de ser asi llaman a la funcion  select_personaje() usando de atributo el id recibido... estoy seguro de que debe haber una manera mas eficiente de usar este codigo. </p>
      <p> despues de investigar un poco en internet, encontre una soluccion con javascript moderno. en lugar de tener un Eventlistener por cada id que quiero buscar les doy a todos los divs que llaman a la funcion la clase "selectable_character", y si detecto que algun elemento con esas clase es clikeado llamo a la funcion select_personaje() con el id de ese elemento. </p>
      <pre><code>
      //seleccionar un personaje --------------------------------------------------------------------------------------
      var personajeID;
      const divs = document.querySelectorAll('.selectable_character');
      divs.forEach(el => el.addEventListener('click', event => {
        personajeID = el.id;
        select_personaje();
      }));
      </pre></code>
      <p> lo bueno de este codigo es que a diferencia de el anterior este no necesita mantenimiento cuando agrege nuevos personajes.</p>
      <h3> la funcion "select_personaje()" </h3>
      <p> bien, ya tengo el id de el div seleccionado, ahora tengo que ver que hago con el</p>
      <p> antes que nada hay que cambiar de secciones, asi que se le da un display none a "seleccion_de_personajes" y display inherit a "personaje_seleccionado". eventualmente si quiero cambiarlo a un fade, voy a tener que hacerlo aca.</p>
      <p> inicialmente habia usado unos if para elegir que mostrar dependiendo el id seleccionado </p>
      <pre><code>
      if (personajeID=="char_1") { document.getElementById("char").innerHTML= personajeID+" personaje 1: Bunny";}
      if (personajeID=="char_2") { document.getElementById("char").innerHTML= personajeID+" personaje 2: Nero";}
      if (personajeID=="char_3") { document.getElementById("char").innerHTML= personajeID+" personaje 3: Shacta" ;} 
      </pre></code>
      <p> aun no estoy convencido de el todo, pero en el nombre de el desarrollo web apropiado lo cambie por un switch</p>
      <pre><code>
      var char_div=  document.getElementById("char");
      switch (personajeID) { 
        case "char_1":
          char_div.innerHTML= "Personaje 1: Bunny";
        break
        case "char_2":
          char_div.innerHTML= "Personaje 2: Nero";
        break
        case "char_3":
          char_div.innerHTML= "Personaje 3: Shacta";
        break
        default:
          char_div.innerHTML= " Error ";
        }
      </pre></code>
      <p> por el momento parece mas codigo para hacer lo mismo, pero confio en que es simplemente mi falta de constumbre en usar switch.</p>
      <p> ahora, los nombres de los personajes se ven perfectos y todo funciona bien...pero el mazo sigue siendo el mismo. vamos a cambiar eso.</p>
      <p> la mejor manera que se me ocurre es incluir el mazo de cada personaje dentro de el switch</p>
      <pre><code>
      var char_div=  document.getElementById("char");
      switch (personajeID) {
        case "char_1":
          char_div.innerHTML= "Personaje 1: Bunny";
          var mazo_inicial = [
            { name: 'carta 1', id: 1 },
            { name: 'carta 2', id: 2 },
            { name: 'carta 3', id: 3 },
            { name: 'carta 4', id: 4 },
            { name: 'carta 5', id: 5 },
            { name: 'carta 6', id: 6 },
            { name: 'carta 7', id: 7 },
            { name: 'carta 8', id: 8 },
            { name: 'carta 9', id: 9 },
            { name: 'carta 10', id: 10 }
          ];
         break
         case "char_2":
           char_div.innerHTML= "Personaje 2: Nero";
           var mazo_inicial = [
             { name: 'carta 11', id: 11 },
             { name: 'carta 12', id: 12 },
             { name: 'carta 13', id: 13 },
             { name: 'carta 14', id: 14 },
             { name: 'carta 15', id: 15 },
             { name: 'carta 16', id: 16 },
             { name: 'carta 17', id: 17 },
             { name: 'carta 18', id: 18 },
             { name: 'carta 19', id: 19 },
             { name: 'carta 20', id: 20 }
           ];
         break
         case "char_3":
           char_div.innerHTML= "Personaje 3: Shacta";
           var mazo_inicial = [
             { name: 'carta 21', id: 21 },
             { name: 'carta 22', id: 22 },
             { name: 'carta 23', id: 23 },
             { name: 'carta 24', id: 24 },
             { name: 'carta 25', id: 25 },
             { name: 'carta 26', id: 26 },
             { name: 'carta 27', id: 27 },
             { name: 'carta 28', id: 28 },
             { name: 'carta 29', id: 29 },
             { name: 'carta 30', id: 30 }
           ];
         break
         default:
           char_div.innerHTML= " Error ";
      }
      </pre></code>
      <p>el problema es que ahora el codigo no funciona porque las funciones que buscan al mazo inicial no encuentran nada, esto es soluccionable moviendo toda esa parte de el codigo dentro de la funcion select_personaje(), sin mencionar que me parece mas ordenado.</p>
      <p> lo unico que me falta agregar es un boton para volver a la seccion de eleccion de personajes, pero sin olvidar limpiar el innerHTML de mazo_inicial_div para que no siga sumando mazos</p>
      <pre><code>
        ------------  html -------------

        &lt button onclick="back_personajes()" > volver a seleccion de personajes &lt/button>
        
        ----------javascript------------
        
        function back_personajes() {
            document.getElementById("mazo_inicial_div").innerHTML=" ";
            document.getElementById("personaje_seleccionado").style.display="none";
            document.getElementById("seleccion_de_personajes").style.display="inherit";
        }
      
      </pre></code>
      <h2 style="    border-bottom: solid 2px #eff0f1;"> v 0.1 </h2>
      <p style=" color: #a0aec1bf;"> 24/3/2020</p>
      <h3> creando el mazo </h3>
      <p> lo primero que tengo que hacer es crear un mazo inicial, eventualmente van a ser varios mazos iniciales depende de que personae se elija. </p>
      <p> en esta caso el mazo es un array de obetos, descubri que esta es la mejor manera de mostrar el mazo por que me permite utilizar las funcionalidades de los array.</p>
      <pre><code>
       var mazo_inicial = [
       { name: 'carta 1', id: 1 },
       { name: 'carta 2', id: 2 },
       { name: 'carta 3', id: 3 },
       { name: 'carta 4', id: 4 },
       { name: 'carta 5', id: 5 },
       { name: 'carta 6', id: 6 },
       { name: 'carta 7', id: 7 },
       { name: 'carta 8', id: 8 },
       { name: 'carta 9', id: 9 },
       { name: 'carta 10', id: 10 }
       ];
      </code></pre>
      <h3> mostrando el mazo </h3>
      <p> para mostrar el mazo solo tengo que crear un div con el id: mazo_inicial_div y usar el siguiente codigo: </p>
      <pre><code>
        // mostrar mazo jugador ------------------
        mazo_inicial.forEach( function(element, index) {
          document.getElementById("mazo_inicial_div").innerHTML += "id: "+ element.id +" name: "+ element.name +" </br>"; 
        });
      </code></pre>
      <p> esto muestra una linea con el id y el nombre por cada objeto dentro del array mazo_inicial </p>
      <p> una vez que se muestra el mazo se puede elegir como mostrarlo, ya sea por nombre, por id o por cualquier atributo que se le agrege, por el momento creo que lo mejor es mostrarlo por orden alfabetico </p>
      <h3> ordenar el array por id </h3>
      <pre><code>
        // ordenar el array ------------------
        mazo_inicial=  mazo_inicial.sort(function(a, b) {
          return a.id-b.id; /* ordenar por id */
        });
      </pre></code>
      <h3> ordenar el array por nombre </h3>
      <pre><code>
        // ordenar el array ------------------
        mazo_inicial=  mazo_inicial.sort(function(a, b) {
          return (a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0); /* ordenar por nombre */
        });
      </pre></code>

      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/pages-themes/cayman">cayman</a> is maintained by <a href="https://github.com/pages-themes">pages-themes</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com/">GitHub Pages</a>.</span>
      </footer>
    </main>
  

</body></html>